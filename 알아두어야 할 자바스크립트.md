# 1. 호출스택

### 동기코드일때

```java
function first() {
	second();
	console.log('첫 번째');
}
function second() {
	third();
	console.log('두 번째');
}
function third() {
	console.log('세 번째');
}
first();
```

- 세 번째 → 두 번째 → 첫 번째

![Untitled](./uploads/6.png)

- 호출 스택
    - Anonymous은 가상의 전역 컨텍스트(항상 있다고 생각하는게 좋음. 파일이 시작될 때 생기고 끝날 때 사라짐)
    - 함수 호출 순서대로 쌓이고, 역순으로 실행됨
    - 함수 실행이 완료되면 스택에서 빠짐
    - LIFO 구조라서 스택이라고 불림
    - first() 가 끝나기 전에 second()를 호출하므로 first()가 사라지지 않고 그 위에 second()가 쌓이게 된다. 만약 first()가 끝나고 난 후 second()를 호출한다면 first()가 사라진 후 second()가 그 자리에 쌓인다.

### 비동기 코드일때

```java
function run() {
	console.log('3초 후 실행');
}
console.log('시작');
setTimeout(run, 3000);
console.log('끝');
```

- 유명한 비동기 코드 setTimeout
- 시작 → 끝 → 3초 후 실행
- 호출스택만으로는 설명이 안됨(run은 호출 안 했는데?)
- 호출 스택 + 이벤트 루프로 설명할 수 있음

![Untitled](./uploads/7.png)

### 호출 스택 연습해보기

```java
function oneMore() {
	console.log('one more');
}
function run() {
	console.log('run run');
	setTimeout(() => {
		console.log('wow');
	}, 0)
	new Promise((resolve) => {
		resolve('hi');
	})
		.then(console.log);
	oneMore();
}

setTimeout(run, 5000);
```

- run run → one more → hi → wow
# const, let

### ES2015 이전에는 var 로 변수를 선언

- ES2015부터는 const 와 let이 대체
- 가장 큰 차이점 : 블록 스코프 (var은 함수 스코프)

```java
if (true) {
	var x = 3;
}
console.log(x);  // 3

if (true) {
	const y = 3;
}
const.log(y);  // Uncaught ReferenceError: y is not defined
```

### 기존 : 함수 스코프(function() {}이 스코프의 기준점)

- 다른 언어와는 달리 if나 for, while은 영향을 미치지 못함
- const와 let은 함수 및 블록({})에도 별도의 스코프를 가짐

  ⇒ var 는 function(){} 쓸때만 못빠져나가고 나머지 블록 (if(){}같은거)에서는 빠져나갈수 있다.
  ⇒ 하지만 const, let은 function(){} 뿐만 아니라 나머지 블록 (if(){}같은거)에서도 빠져나갈 수 없다.
  ⇒ var 스코프 : function() {}, let const 스코프 : 모든 {}


### const

- const 는 상수
- 상수에 할당한 값은 다른 값으로 변경 불가
- 변경하고자 할 때에는 let 으로 변수 선언
- 상수 선언시부터 초기화가 필요함

```java
const a = 3;
a = '5';  // 에러

const b = { name: 'zerocho' };
b.name = 'nerocho';

const c;  // 에러
```

- 객체 내부 값을 변경하는 것은 가능

### let

- 값 변경 필요시에는 let 사용

```java
let c = 5;
c = 3;
c = 10;
```

# 템플릿 문자열

- ES2015부터는 문자열 합칠 때 `(백틱) 사용가능
- 백틱 문자열 안에 ${변수} 처럼 사용
- 함수 호출시 a() 말고도 a`` 이렇게 호출 가능 (태그드 템플릿 리터럴)

```java
var won = 1000;
var result = '이 과자는 ' + won + '원입니다.';
// 이 과자는 1000원입니다.

const result = `이 과자는 ${won}원입니다.`;

function a() {}
a();
a``; // 태그드 템플릿 리터럴. 함수 호출 가능

```

# 객체 리터럴

- 객체이 메서드에 function을 붙이지 않아도 됨
- {sayNode: sayNode}와 같은 것을 {sayNode}로 축약 가능
- [변수 + 값] 등으로 동적 속성명을 객체 속성 명으로 사용 가능

```java
const newObject = {
	sayJS() {
		console.log('JS');
	},
	sayNode,
	[es + 6]: 'Fantastic',
};
newObject.sayJS();  // JS
```

# 화살표 함수

```java
function add1(x, y) {
	return x + y;
}

const add2 = (x, y) => {
	return x + y;
};

const add3 = (x, y) => x + y;

const add4 = (x, y) => (x + y);

function not1(x) {
	return !x;
}

const not2 = x => !x;

const obj = {x, y) => ({x, y});  // 바로 객체를 리턴하는 경우에만 소괄호
```

- 화살표 함수가 기존 function() {}을 대체하는 건 아님(this가 달라짐)

```java
var relationship1 = {
	name: 'zero',
	friends: ['nero', 'hero', 'xero'],
	logFriends: function() {
		var that = this;  // relationship1을 가리키는 this를 that에 저장
		this.friends.forEach(function (friend) {
			console.log(that.name, friend);
		});
	},
};
relationship1.logFriends();
// zero nero
// zero hero
// zero xero
```

- function은 자신만의 this를 가지기 때문에 개발할때에는 항상 함수전에 변수에 따로 this를 담아줘야 했다.
- 화살표함수는 부모의 this를 물려받으므로 변수에 따로 담아줄 필요가 없다.

```java
const relationship2 = {
	name: 'zero',
	friends: ['nero', 'hero', 'xero'],
	logFriends() {
			this.friends.forEach(friend => {
				console.log(this.name, friend);
			});
	},
};
relationship2.logFriends();
// zero nero
// zero hero
// zero xero
```

```java
button.addEventListener('click', (e) => {
	console.log(this.textContext);
});
// 화살표 함수이므로 this는 자기자신이 아닌 바깥에 있는게 this가 된다.
```

# 비구조화 할당

```java
const example = { a: 123, b: { c: 135, d: 146}}
const a = example.a;
const d = example.b.d;

const { a, b: { d }} = example;
console.log(a);  // 123
console.log(d);  // 146

arr = [1, 2, 3, 4, 5];
const x = arr[0];
const x = arr[1];
const x = arr[4];

const [x, y, , , z] = arr;
```

```java
const candyMachine = {
	status: {
		name: 'node',
		count: 5,
	},
	getCandy() {
		this.status.count--;
		return this.status.count;
	},
};
const { getCandy, status: { count} } = candyMachine;
```

- this 사용할 경우에 구조분해를 하면 문제가 생기기 때문에 this 있을 때에는 구조분해를 안하는 것이 좋다.

# 클래스

### 프로토타입 문법을 깔끔하게 작성할 수 있는 Class 문법 도입

- Constructor(생성자), Extends(상속) 등을 깔끔하게 처리할 수 있음
- 코드가 그룹화되어 가독성이 향상됨
- Class 문법 도입 전

```java
var Human = function(type) {
	this.type = type || 'human';
};

Human.isHuman = function(human) {
	return human instanceof Human;
}

Human.prototype.breathe = function() {
	alert('h-a-a-a-m');
};

var Zero = function(type, firstName, lastName) {
	Humane.apply(this, arguments);
	this.firstName = firstName;
	this.lastName = lastName;
};

Zero.prototype = Object.create(Human.prototype);
Zero.prototype.constructor = Zero;  // 상속하는 부분
Zero.prototype.sayName = function() {
	alert(this.firstName + ' ' + this.lastName);
};
var oldZero = new Zero('human', 'Zero', 'Cho');
Human.isHuman(oldZero);  // true
```

- Class 문법 도입 후
- Super 로 부모 Class 호출
- Static 키워드로 클래스 메서드 생성

```java
class Human {
	constructor(type = 'human') {
		this.type = type;
	}

	static isHuman(human) {
		return human instanceof Human;
	}

	breathe() {
		alert('h-a-a-a-m');
	}
}

class Zero extends Human {
	constructor(type, firstName, lastName) {
		super(type);
		this.firstName = firstName;
		this.lastNAme = lastName;
	}

	sayName() {
		super.breathe();
		alert(`${this.firstName} ${this.lastName}`);
	}
}

const newZero = new Zero('human', 'Zero', 'Cho');
Human.isHuman(newZero);  // true

```

# Promise

### 콜백 헬이라고 불리는 지저분한 자바스크립트 코드의 해결책

- 프로미스: 내용이 실행은 되었지만 결과를 아직 반환하지 않은 객체
- Then을 붙이면 결과를 반환함
- 실행이 완료되지 않았으면 완료된 후에 Then 내부 함수가 실행됨

```java
const condition = true;  // true면 resolve, false면 reject
const promise = new Promise((resolve, reject) => {
	if (condition) {
		resolve('성공');
	} else {
		reject('실패');
	}
});
// 여기까지는 동기로 실행됨
// 다른 코드가 들어갈 수 있음
promise
	.then((message) => {
		console.log(message);  // 성공(resolve) 한 경우 실행
	})
	.catch((error) => {
		console.error(error);  // 실패(reject)한 경우 실행
	})
	.finally(() => {
		console.log('무조건');
	});

```

- Resolve(성공리터값) → then으로 연결
- Reject(실패리턴값) → catch로 연결
- Finally 부분은 무조건 실행됨
- 앞에 new Promise 쪽에서 일단 실행 해 놓고 값을 promise 변수에서 들고있다가 원할때 꺼내 쓸 수 있다.
- 콜백함수와 다른점은 콜백함수는 항상 코드가 붙어 있어서 바로 실행되지만 프로미스는 코드를 분리할 수 있다.

```java
// 콜백
setTimeout(() => {
});

// 프로미스
const promise = setTimeoutPromise(3000);

console.log('딴짓');
console.log('딴짓');
console.log('딴짓');
console.log('딴짓');

promise.then(() => {
	// 지금할래
});
```

- 노드쪽에서는 대부분의 함수가 콜백에서 프로미스로 변하고 있기 때문에 중요하다

### 프로미스의 then 연달아 사용 가능(프로미스 체이닝)

- then 안에서 return 한 값이 다음 then으로 넘어감
- return 값이 프로미스면 resolve 후 넘어감
- 에러가 난 경우 바로 catch로 이동
- 에러는 catch에서 한 번에 처리

```java
promise
	.then((message) => {
		return new Promise((resolve, reject) => {
			resolve(message);
		});
	})
	.then((message2) => {
		console.log(message2);
		return new Promise((resolve, reject) => {
			resolve(message2);
		});
	})
	.then((message3) => {
		console.log(message3);
	})
	.catch((error) => {
		console.error(error);
	});
```

### 콜백 패턴(3중첩)을 프로미스로 바꾸기 (콜백 헬)

```java
function findAndSaveUser(Users) {
	Users.findOne({}, (err, user) => {  // 첫 번째 콜백
		if (err) {
			return console.error(err);
		}
		user.name = 'zero';
		user.save((err) => {  // 두 번째 콜백
			if (err) {
				return console.error(err);
			}
			Users.findOne({ gender: 'm'}, (err, user) => {  // 세 번째 콜백
				// 생략
			});
		});
	});
}
```

```java
function findAndSaveUser(Users) {
	Users.findOne({})
		.then((user) => {
			user.name = 'zero';
			return user.save();
		})
		.then((user) => {
			return Users.findOne({ gender: 'm'});
		})
		.then((user) => {
			// 생략
		})
		.catch(err => {
			console.error(err);
		});
}
```

- Promise.resolve(성공리턴값) : 바로 resolve하는 프로미스
- Promise.reject(실패리턴값) : 바로 reject하는 프로미스

```java
const promise1 = Promise.resolve('성공1');
const promise2 = Promise.resolve('성공2');
Promise.all([promise1, promise2])
	.then((result) => {
		console.log(result);  // ['성공1', '성공2'];
	})
	.catch((error) => {
		console.error(error);
	});
```

- Promise.all(배열) : 여러 개의 프로미스를 동시에 실행
  - 하나라도 실패하면 catch로 감
  - allSettled로 실패한 것만 추려낼 수 있음

# async/await

이전 챕터의 프로미스 패턴 코드 Async/await으로 한번 더 축약 가능

```java
function findAndSaveUser(Users) {
	Users.findOne({})
		.then((user) => {
			user.name = 'zero';
			return user.save();
		})
		.then((user) => {
			return Users.findOne({ gender: 'm'});
		})
		.then((user) => {
			// 생략
		})
		.catch(err => {
			console.error(err);
		});
}
```

- async fiunction의 도입
- 변수 = await 프로미스; 인 경우 프로미스가 resolve된 값이 변수에 저장
- 변수 await 값; 인 경우 그 값이 변수에 저장

```java
async function findAndSaveUser(Users) {
	let user = await Users.findOne({});
	user.name = 'zero';
	user = await user.save();
	user = await User.findOne({ gender: 'm' });
	// 생략
}
```

- await을 then 으로 생각하고 오른쪽에서 왼쪽으로 간다고 생각하면 된다.

```java
const promise = new Promise(...)

promise.then((result) => ...)

// await 사용하고 싶을때
// 전에는 function 앞에 async 를 붙여줘야 했다.
async function main() {
	const result = await promise;
}

// 지금은 안붙여줘도 가능
const result = await promise;

// async 함수에서 리턴한 값은 무조건 함수.then으로 받아야 한다.
async function main() {
	const result = await promise;
	return 'zerocho';
}

main().then((name) => ...)

// then 안하고 하는 방법 (async 도 프로미스이므로 이 점을 이용)
const name = await main();

```

- async 도 프로미스 이므로 프로미스의 성질을 그대로 가진다.
- async / await 사용시에는 에러 처리를 위해 catch 대신 try catch 사용

```java
async function main() {
	try {
		const result = await promise;
		return result;
	} catch (error) {
		
	}
}
```

- 화살표 함수도 async / await 가능

```java
const findAndSaveUser = async (Users) => {
	try {
		let user = await Users.findOne({});
		user.name = 'zero';
		user = await user.save();
		user = await Users.findOne({ gender: 'm'});
		// 생략
	} catch (error) {
		console.error(error);
	}
};
```

- Async 함수는 항상 promise를 반환
  - Then이나 await을 붙일 수 있음

```java
async function findAndSaveUser(Users) {
	// 생략
}
findAndSaveUser().then(() => {
	// 생략
});
// 또는
async function other() {
	const result = await findAndSaveUser();
}
```

### for await of

- 노드 10부터 지원
- for await (변수 of 프로미스 배열)
  - resolve된 프로미스가 변수에 담겨 나옴
  - await을 사용하기 때문에 async 함수 안에서 해야함

```java
const promise1 = Promise.resolve('성공1');
const promise2 = Promise.resolve('성공2');
(async () => {
	for await (promise of [promise1, promise2]) {
		console.log(promise);
	}
})();
```