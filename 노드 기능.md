# REPL

자바스크립트는 스크립트 언어라서 즉석에서 코드를 실행할 수 있음

- REPL 이라는 콘솔 제공
- R(Read), E(Evaluate), P(Print), L(Loop)
- 윈도에서는 명령프롬프트, 맥이나 리눅스에서는 터미널에 node 입력

# 모듈

노드는 자바스크립트 코드를 모듈로 만들 수 있음

- 모듈 : 특정한 기능을 하는 함수나 변수들의 집합
- 모듈로 만들면 여러 프로그램에서 재사용 가능

![Untitled](./uploads/8.png)

- 파일끝에 module.exports로 모듈로 만들 값을 지정
- 다른 파일에서 require(파일 경로)로 그 모듈의 내용 가져올 수 있음
- require로 받아올 때 구조분해 가능

    ```java
    const { odd, even } = require('./var');
    ```

- 이거는 노드의 모듈시스템이고 자바스크립트의 모듈시스템은 따로 있다.

  module.exports → export default

  const { odd, even } = require('./var'); → import { odd, even } from './var';

    - 그렇다고 module.exports 와 export defalut 가 같고, const {} = require(); 와 import {} from '' 이 같은 건 아니므로 바꿔도 안바꿔지는 경우도 있다.

# 노드 내장 객체

## global

노드의 전역 객체

- 브라우저의 window같은 역할
- 모든 파일에서 접근 가능
- window처럼 생략도 가능(console, require도 global의 속성)

## console 객체

브라우저의 console 객체와 매우 유사

- console.time, console.timeEnd: 시간 로깅
- console.error: 에러 로깅
- console.log: 평범한 로그
- console.dir: 객체 로깅
- console.trace: 호출스택 로깅

## 타이머 메서드

set 메서드에 clear 메서드가 대응됨

- set 메서드의 리턴 값(아이디)을 clear 메서드에 넣어 취소
- setTimeout(콜백함수, 밀리초) : 주어진 밀리초(1000분의 1초) 이후에 콜백함수를 실행합니다.
- setInterval(콜백함수, 밀리초) : 주어진 밀리초마다 콜백 함수 반복 실행
- setImmediate(콜백 함수) : 콜백 함수를 즉시 실행
- clearTimeout(아이디) : setTimeout을 취소
- clearInterval(아이디) : setInteral을 취소
- clearImmediate(아이디) : setImmediate를 취소

## __filename, __dirname

- __filename : 현재 파일 경로
- __dirname : 현재 폴더(디렉토리) 경로

## module, exports

module.exports 외에도 exports로 모듈을 만들 수 있음

```java
exports.odd = '홀수입니다';
exports.even = '짝수입니다.';
```

- 동일한 이유는 module.exports와 exports가 참조관계이기 때문
- exports에 객체의 속성이 아닌 다른 값을 대입하면 참조관계가 깨짐
- exports = module.exports = {}

## this

노드에서 this를 사용할 때 주의점이 있음

- 최상위 스코프의 this는 module.exports를 가리킴
- 그 외에는 브라우저의 자바스크립트와 동일
- 함수 선언문 내부의 this는 global(전역) 객체를 가리킴

## require의 특성

- require가 제일 위에 올 필요는 없음 (import 같은 경우는 제일 위에 와야함)
- require.cache에 한번 require한 모듈에 대한 캐슁 정보가 들어있음
- require.main은 노드 실행 시 첫 모듈을 가리킴

## 순환 참조

두 개의 모듈이 서로를 require하는 상황을 조심해야 함

- Dep1이 dep2를 require 하고, dep2가 dep1을 require 함
- Dep1의 module.exports가 함수가 아니라 빈 객체가 됨 (무한 반복을 막기 위해 의도됨)
- 순환참조하는 상황이 나오지 않도록 하는 게 좋음

## process

현재 실행중인 노드 프로세스에 대한 정보를 담고 있음

- 컴퓨터마다 출력값이 PPT와 다를 수 있음

![Untitled](./uploads/9.png)

## process.env

시스템 환경 변수들이 들어있는 객체

- 비밀키(데이터베이스 비밀번호, 서드파티 앱 키 등)를 보관하는 용도로도 쓰임
- 환경 변수는 process.env로 접근 가능

    ```java
    const secretId = process.env.SECRET_ID;
    const secretCode = process.env.SECRET_CODE;
    ```

- 일부 환경 변수는 노드 실행 시 영향을 미침
- 예시) NODE_OPTIONS(노드실행옵션), UV_THREADROOL_SIZE(스레드풀 개수)
    - max-old-space-size는 노드가 사용할 수 있는 메모리를 지정하는 옵션

## process.nexttTick(콜백)

이벤트 루프가 다른 콜백 함수들보다 nextTick의 콜백 함수를 우선적으로 처리함

- 너무 남용하면 다른 콜백 함수들 실행이 늦어짐
- 비슷한 경우로 promise가 있음(nextTick처럼 우선순위가 높음)
- 아래 예제에서 setImmediate, setTimeout 보다 promise와 nextTick이 먼저 실행됨

```java
setImmediate(() => {
	console.loog('immediate');
});
process.nextTick(() => {
	console.log('nextTick');
});
setTimeout(() => {
	console.log('timeout');
}, 0);
Promise.resolve().then(() => console.log('promise'));

// nextTick
// promise
// timeout
// immediate
```

## process.exit(코드)

현재의 프로세스를 멈춤

- 코드가 없거나 0이면 정상 종료
- 이외의 코드는 비정상종료를 의미함
## os

운영체제의 정보를 담고 있음

- 모듈은 require로 가져옴(내장 모듈이라 경로 대신 이름만 적어줘도 됨)

```java
const os = require('os');

os.arch()  // process.arch와 동일
os.platform()  // process.platform 과 동일
os.type()  // 운영체제의 종류
os.uptime()  // 운영체제 부팅 이후 흐른 시간(초)을 보여줌 (process.uuptime()은 노드의 실행 시간)
os.hostname()  // 컴퓨터의 이름
os.release()  // 운영체제의 버전
os.homedir()  // 홈 디렉토리 경로
os.tmpdir()  // 임시 파일 저장 경로
os.cpus()  // 컴퓨터의 코어 정보
os.freemem()  // 사용 가능한 메모리(RAM)
os.totalmem()  // 전체 메모리 용량
```

## path

폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈

- 운영체제별로 경로 구분자가 다름(Windows: '\', POSIX(max이랑 linux를 합침): '/')
- ./ : 현재 경로  ../ : 부모 경로  / : 절대경로(C드라이브)

```java
const path = require('path');

path.sep  // 경로의 구분자. Windows는 \, POSIZ는 / 이다.
path.delimiter  // 환경변수의 구분자. process.env.PATH를 입력하면 여러 개의 경로가 이 구분자로 구분되어 있다. Windows는 세미콜론이고, POSIX는 콜론이다.
path.dirname(경로)  // 파일이 위치한 폴더 경로를 보여준다
path.extname(경로)  // 파일의 확장자를 보여준다.
path.basename(경로, 확장자)  // 파일의 이름(확장자 포함)을 보여준다. 파일의 이름만 표시하고 싶다면 basename의 두 번째 인자로 파일의 확장자를 넣어주면 된다.
path.parse(경로)  // 파일 경로를 root, dir, base, ext, name으로 분리한다.
path.format(객체)  // path.parse()한 객체를 파일 경로로 합친다.
path.normalize(경로)  // /나 \를 실수로 여러 번 사용했거나 혼용했을 때 정상적인 경로로 변환
path.isAbsolute(경로)  // 파일의 경로가 절대경로인지 상대경로인지 true나 false로 알려줌
path.relative(기준경로, 비교경로)  // 경로를 두 개 넣으면 첫 번째 겨로에서 두 번째 경로로 가는 방법을 알려줌
path.join(경로, .. )  // 여러 인자를 넣으면 하나의 경로로 합쳐준다. 상대경로인 ..(부모 디렉토리)과 .(현 위치)도 알아서 처리해준다.
path.resolve(경로, ..)  // path.join()과 비슷하지만 차이가 있다. 
```

join과 resolve의 차이 : resolve는 /를 절대경로로 처리, join은 상대경로로 처리

- 상대 경로 : 현재 파일 기준. 같은 경로면 점 하나(.), 한단계 상위 경로면 점 두개(..)
- path.join(__dirname, '..', '/var.js'); → 절대경로 /가 있으면 /var.js에서 /를 없다고 치고 var.js로 처리함
- path.resolve(__dirname, '..', '/var.js'); → 절대경로 /가 있으면 앞의 것 (__dirname, '..')을 무시

\\ 와 \ ckdl : \는 윈도 경로 구분자, \\는 자바스크립트 문자열안에서 사용(\가 특수문자라 \\로 이스케이프 해준 것)

윈도에서 POSIX path를 쓰고 싶다면 : path.posix 객체 사용

- POSIX에서 윈도 path를 쓰고 싶다면 : path.win32 객체 사용

## url 모듈

인터넷 주소를 쉽게 조작하도록 도와주는 모듈

- url 처리에 크게 두 가지 방식이 있음(기존 노드 방식 vs WHATWG 방식)
- 아래 그림에서 가운데 주소를 기준으로 위쪽은 기존 노드 방식, 아래쪽은 WHATWG 방식

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/64e8fd2f-35c4-4cc9-abef-46eee7f3cd07/Untitled.png)

```java
const url = require('url');

const { URL } = rul
const myURL = new URL('http://www.gilbut.co.kr/book/bookList.aspx?sercate1=001001000#anchor');
console.log('new URL():', myURL);
console.log('url.format():', url.format(myURL));
console.log('-----------------');
const parsedUrl = url.parse('http://www.gilbut.co.kr/book/bookList.aspx?sercate1=001001000#anchor');
console.log('url.parse():', parseUrl);
console.log('url.format():', url.format(parseUrl));
```

- url 모듈 안에 URL 생성자가 있습니다. 이 생성자에 주소를 넣어 객체로 만들면 주소가 부분별로 정리된다. 이 방식이 WHATWG의 url 이다. WHATWG에만 있는 username, password, origin, searchParams 속성이 존재

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/35f8c159-d3d1-4580-817b-cdaf8c3dbf6d/Untitled.png)

기존 노드 방식 메서드

- url.parse(주소) : 주소를 분해한다. WHATWG 방식과 비교하면 username과 password대신 auth 속성이 있고, searchParams 대신 query가 있다.
- url.format(객체) : WHATWG 방식의 url과 기존 노드의 url 모두 사용할 수 있다. 분해되었던 url 객체를 다시 원래 상태로 조립한다.

## searchParams

WHATWG방식에서 쿼리스트링 부분 처리를 도와주는 객체

- ?page=37limit=10&catgory=nodejs&category=javascript 부분

```java
const { URL } = require('url');
const myURL = new URL('http://www.gilbut.co.kr/?page=37limit=10&catgory=nodejs&category=javascript');

myURL.searchParams.getAll(키)  // 키에 해당하는 모든 값들을 가져온다. category 키에는 두 가지 값, 즉 nodejs와 javascript의 값이 들어있다.
myURL.searchParams.get(키)  // 키에 해당하는 첫 번째 값만 가져온다.
myURL.searchParams.has(키)  // 해당 키가 있는지 없는지를 검사
myURL.searchParams.heys()  // searchParams의 모든 키를 반복기 객체로 가져온다.
myURL.searchPArams.values()  // searchParams의 모든 값을 반복기 객체로 가져온다.
myURL.searchParams.append(키, 값)  // 해당 키를 추가한다. 같은 키의 값이 있다면 유지하고 하나 더 추가한다. 
myURL.searchParams.set(키, 값)  // append와 비슷하지만 같은 키의 값이 있다면 유지하고 하나 더 추가한다.
myURL.searchParams.delete(키)  // goekd zlfmf wprjgksek.
myURL.searchParams.toString()  // 조작한 searchParams 객체를 다시 문자열로 만든다. 이 문자열을 search에 대입하믄 주소 객체에
```

## querystring

기존노드방식에서는 url querystring을 querystring모듈로 처리

- querystring.parse(쿼리) : url의 query부분을 자바스크립트 객체로 분해
- querystring.stringify(객체) : 분해된 query 객체를 문자열로 다시 조립한다.

```java
const url = require('url');
const querystring = require('querystring');

const parseUrl = url.parse('http://www.gilbut.co.kr/?page=3?limit=10&category=nodejs&category=javascript');
const query = querystring.parse(parsedUrl.query);
console.log('querystring.parse():', query);
console.log('querystring.stringify():', querystring,stringify(query));
```